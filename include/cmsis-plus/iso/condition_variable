/*
 * This file is part of the ÂµOS++ distribution.
 *   (https://github.com/micro-os-plus)
 * Copyright (c) 2016 Liviu Ionescu.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * This file is part of the CMSIS++ proposal, intended as a CMSIS
 * replacement for C++ applications.
 *
 * The code is inspired by LLVM libcxx and GNU libstdc++-v3.
 */

#ifndef CMSIS_PLUS_STD_CONDITION_VARIABLE_
#define CMSIS_PLUS_STD_CONDITION_VARIABLE_

// ----------------------------------------------------------------------------

#include <cmsis-plus/rtos/os.h>
#include <cmsis-plus/diag/trace.h>

#include <cmsis-plus/iso/mutex>
#include <memory>
#include <chrono>

// ----------------------------------------------------------------------------

namespace os
{
  namespace estd
  {
    /**
     * @ingroup cmsis-plus-iso
     * @{
     */

    // ========================================================================
    /**
     * Condition variables provide synchronization primitives used
     * to block a thread until notified by some other thread that
     * some condition is met or until a system time is reached.
     * Class `condition_variable` provides a condition variable
     * that can only wait on an object of type `unique_lock<mutex>`,
     * allowing maximum efficiency on some platforms. Class
     * `condition_variable_any` provides a general condition
     * variable that can wait on objects of user-supplied
     * lock types.
     *
     * Condition variables permit concurrent invocation of
     * the `wait`, `wait_for`, `wait_until`, `notify_one`
     * and `notify_all` member functions.
     */

    enum class cv_status
    {
      no_timeout, //
      timeout
    };

    class condition_variable
    {
    private:

      using native_type = os::rtos::condition_variable;

    public:

      using native_handle_type = native_type*;

      condition_variable ();

      ~condition_variable ();

      condition_variable (const condition_variable&) = delete;
      condition_variable&
      operator= (const condition_variable&) = delete;

      void
      notify_one () noexcept;

      void
      notify_all () noexcept;

      void
      wait (unique_lock<mutex>& lock);

      template<class Predicate_T>
        void
        wait (unique_lock<mutex>& lock, Predicate_T pred);

      template<class Clock_T, class Duration_T>
        cv_status
        wait_until (
            unique_lock<mutex>& lock,
            const std::chrono::time_point<Clock_T, Duration_T>& abs_time);

      template<class Clock_T, class Duration_T, class Predicate_T>
        bool
        wait_until (
            unique_lock<mutex>& lock,
            const std::chrono::time_point<Clock_T, Duration_T>& abs_time,
            Predicate_T pred);

      template<class Rep_T, class Period_T>
        cv_status
        wait_for (unique_lock<mutex>& lock,
                  const std::chrono::duration<Rep_T, Period_T>& rel_time);

      template<class Rep_T, class Period_T, class Predicate_T>
        bool
        wait_for (unique_lock<mutex>& lock,
                  const std::chrono::duration<Rep_T, Period_T>& rel_time,
                  Predicate_T pred);

      native_handle_type
      native_handle ();

    protected:

      native_type ncv_;
      using Native_clock = chrono::systick_clock;

    };

    void
    notify_all_at_thread_exit (condition_variable& cond, unique_lock<mutex> lk);

    class condition_variable_any
    {
    public:

      condition_variable_any ();

      ~condition_variable_any ();

      condition_variable_any (const condition_variable_any&) = delete;
      condition_variable_any&
      operator= (const condition_variable_any&) = delete;

      void
      notify_one () noexcept;

      void
      notify_all () noexcept;

      template<class Lock_T>
        void
        wait (Lock_T& lock);

      template<class Lock_T, class Predicate_T>
        void
        wait (Lock_T& lock, Predicate_T pred);

      template<class Lock_T, class Clock_T, class Duration_T>
        cv_status
        wait_until (
            Lock_T& lock,
            const std::chrono::time_point<Clock_T, Duration_T>& abs_time);

      template<class Lock_T, class Clock_T, class Duration_T, class Predicate_T>
        bool
        wait_until (
            Lock_T& lock,
            const std::chrono::time_point<Clock_T, Duration_T>& abs_time,
            Predicate_T pred);

      template<class Lock_T, class Rep_T, class Period_T>
        cv_status
        wait_for (Lock_T& lock,
                  const std::chrono::duration<Rep_T, Period_T>& rel_time);

      template<class Lock_T, class Rep_T, class Period_T, class Predicate_T>
        bool
        wait_for (Lock_T& lock,
                  const std::chrono::duration<Rep_T, Period_T>& rel_time,
                  Predicate_T pred);

    protected:

      condition_variable cv_;
      std::shared_ptr<mutex> mx_;

      using Native_clock = chrono::systick_clock;

    };

  /**
   * @}
   */

  } /* namespace estd */
} /* namespace os */

// ============================================================================
// Inline & template implementations.

namespace os
{
  namespace estd
  {
    // ========================================================================

    inline
    condition_variable::condition_variable ()
    {
      ;
    }

    inline
    condition_variable::~condition_variable ()
    {
      ;
    }

    template<class Predicate_T>
      void
      condition_variable::wait (unique_lock<mutex>& lock, Predicate_T pred)
      {
        while (!pred ())
          wait (lock);
      }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Waggregate-return"

    template<class Clock_T, class Duration_T>
      cv_status
      condition_variable::wait_until (
          unique_lock<mutex>& lock,
          const std::chrono::time_point<Clock_T, Duration_T>& abs_time)
      {
        using namespace std::chrono;
        using clock = Clock_T;

#if 0
        wait_for (lock, abs_time - Clock_T::now ());
        return
        Clock_T::now () < abs_time ?
        cv_status::no_timeout : cv_status::timeout;
#else
        // Optimise to native (ticks). LLVM compares using the
        // original clock, which might be more accurate.
        Native_clock::duration rel_time = std::chrono::duration_cast<
            Native_clock::duration> (abs_time - clock::now ());
        return wait_for (lock, rel_time);
#endif
      }

#pragma GCC diagnostic pop

    template<class Clock_T, class Duration_T, class Predicate_T>
      bool
      condition_variable::wait_until (
          unique_lock<mutex>& lock,
          const std::chrono::time_point<Clock_T, Duration_T>& abs_time,
          Predicate_T pred)
      {
        while (!pred ())
          {
            if (wait_until (lock, abs_time) == cv_status::timeout)
              return pred ();
          }
        return true;
      }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Waggregate-return"

    template<class Rep_T, class Period_T>
      cv_status
      condition_variable::wait_for (
          unique_lock<mutex>& lock,
          const std::chrono::duration<Rep_T, Period_T>& rel_time)
      {
        using namespace std::chrono;

        if (rel_time <= rel_time.zero ())
          {
            return cv_status::timeout;
          }

        Native_clock::time_point start_tp = Native_clock::now ();

        rtos::clock::duration_t ticks = os::estd::chrono::ceil<
            std::chrono::duration<rtos::clock::duration_t,
                typename Native_clock::period>> (rel_time).count ();

        ncv_.timed_wait (
        /*(rtos::mutex &)*/(*(lock.mutex ()->native_handle ())),
                         ticks);

        return
            (Native_clock::now () - start_tp) < rel_time ?
                cv_status::no_timeout : cv_status::timeout;
      }

    template<class Rep_T, class Period_T, class Predicate_T>
      inline
      bool
      condition_variable::wait_for (
          unique_lock<mutex>& lock,
          const std::chrono::duration<Rep_T, Period_T>& rel_time,
          Predicate_T pred)
      {
        return wait_until (lock, Native_clock::now () + rel_time,
                           std::move (pred));
      }

#pragma GCC diagnostic pop

    // ========================================================================

    inline
    condition_variable_any::condition_variable_any () :
        cv_
          { }, //
        mx_
          { std::make_shared<mutex> () }
    {
      ;
    }

    inline
    condition_variable_any::~condition_variable_any ()
    {
      ;
    }

    inline void
    condition_variable_any::notify_one () noexcept
    {
      lock_guard<mutex> lock (*mx_);
      cv_.notify_one ();
    }

    inline void
    condition_variable_any::notify_all () noexcept
    {
      lock_guard<mutex> lock (*mx_);
      cv_.notify_all ();
    }

    struct __lock_external
    {
      template<class Lock_T>
        void
        operator() (Lock_T* lk)
        {
          lk->lock ();
        }
    };

    template<class Lock_T>
      void
      condition_variable_any::wait (Lock_T& lock)
      {
        std::shared_ptr<mutex> mx = mx_;
        unique_lock<mutex> lk (*mx);
        lock.unlock ();
        std::unique_ptr<Lock_T, __lock_external> lxx(&lock);
        lock_guard<unique_lock<mutex> > lx (lk, adopt_lock);
        cv_.wait (lk);
        // mx.unlock()
        // lock.lock()
      }

    template<class Lock_T, class Predicate_T>
      inline void
      condition_variable_any::wait (Lock_T& lock, Predicate_T pred)
      {
        while (!pred ())
          wait (lock);
      }

    template<class Lock_T, class Clock_T, class Duration_T>
      cv_status
      condition_variable_any::wait_until (
          Lock_T& lock,
          const std::chrono::time_point<Clock_T, Duration_T>& abs_time)
      {
        std::shared_ptr<mutex> mx = mx_;
        unique_lock<mutex> lk (*mx);
        lock.unlock ();
        std::unique_ptr<Lock_T, __lock_external> lxx(&lock);
        lock_guard<unique_lock<mutex> > lx (lk, adopt_lock);
        return cv_.wait_until (lk, abs_time);
        // mx.unlock()
        // lock.lock()
      }

    template<class Lock_T, class Clock_T, class Duration_T, class Predicate_T>
      inline bool
      condition_variable_any::wait_until (
          Lock_T& lock,
          const std::chrono::time_point<Clock_T, Duration_T>& abs_time,
          Predicate_T pred)
      {
        while (!pred ())
          {
            if (wait_until (lock, abs_time) == cv_status::timeout)
              {
                return pred ();
              }
          }
        return true;

      }

    template<class Lock_T, class Rep_T, class Period_T>
      inline cv_status
      condition_variable_any::wait_for (
          Lock_T& lock, const std::chrono::duration<Rep_T, Period_T>& rel_time)
      {
        return wait_until (lock, Native_clock::now () + rel_time);
      }

    template<class Lock_T, class Rep_T, class Period_T, class Predicate_T>
      inline bool
      condition_variable_any::wait_for (
          Lock_T& lock, const std::chrono::duration<Rep_T, Period_T>& rel_time,
          Predicate_T pred)
      {
        return wait_until (lock, Native_clock::now () + rel_time,
                           std::move (pred));
      }

  // --------------------------------------------------------------------------

  } /* namespace estd */
} /* namespace os */

// ----------------------------------------------------------------------------

#endif /* CMSIS_PLUS_STD_CONDITION_VARIABLE_ */
